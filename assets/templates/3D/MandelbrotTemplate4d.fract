{"compilers":[{"isCurrent":true,"languageName":"HLSL","shaderName":"NewShader","source":"//It is possible to redefine float as double for better precision\n//(performance will be decreased significantly)\n//#define float2 double2\n//#define float double\n\n//define parameters\nstruct Parameters \n{\n\n\tfloat a1;\n\tfloat a2;\n\t//space transform:\n    float2 move; \n   \tfloat zoom;\n   \tfloat rotation;\n\n\t//mandelbrot-like fractal specific parameters:\n\tfloat accuracy; \n    int mode;\n    float2 c;//Julian point\n    float contrast;\n    float radius;\n    float4 color;\n    \n    //preview parameters:\n    bool showUVRect;\n\n    //reserved parameters,autoupdated by app:\n    float2 extent;//render area extent in pixels\n\tfloat2 mouse_pos;//current mouse position in pixels\n\tfloat2 mouse_delta;//mouse delta for the last frame in pixels\n\tfloat mouse_wheel_delta;//mouse wheel delta for the last frame\n\tbool lmb_down;//if left mouse button down\n\tbool rmb_down;//if right mouse button down\n\tbool mmb_down;//if middle mouse button down\n\tfloat t;//time counter\n\tfloat dt;//time passed from last frame\n};\n\n//define parameters variable p\nInputParameters(Parameters,p);\n\n\nfloat fractal(float2 uv,int accuracy,float2 init)\n{\n    float2 sp= uv;\n    int i=0;\n    float r_sqr=p.radius*p.radius;\n    while(((sp.x*sp.x+sp.y*sp.y)<r_sqr)&&i<=accuracy)\n    {\n        sp= float2(sp.x * sp.x - sp.y * sp.y, 3.0 * sp.x * sp.y*sp.y)+init;\n        ++i;\n    }\n    return pow(i/(float)accuracy,p.contrast/11.0);\n}\n\n\nfloat2 uvToSpacePoint(float2 uv)\n{\n\treturn uv / p.zoom +p.move;\n}\n\nfloat2 spacePointToUv(float2 spacePoint)\n{\n\treturn (spacePoint-p.move)*p.zoom;\n}\n\n//This function will be the result of export\n//Pass parameters through function arguments for dynamic parameters\nfloat4 output(float2 uv)\n{\n\tfloat2 pos = uvToSpacePoint(uv);\n\n\n\n\tfloat4 result=0;\n\tif(p.mode!=0)\n   \t\tresult+= fractal(pos,p.accuracy,p.c);\n    if(p.mode!=2)\n   \t \tresult+= fractal(pos,p.accuracy,pos);\n\n   \tif(p.mode%2==1)\n   \t\tresult/=2;\n\n   \treturn result*p.color;\n}\n\nfloat2 screenToUV(float2 screenPosition)\n{\n\treturn float2(screenPosition.x*p.extent.x/p.extent.y, -screenPosition.y)+0.5;\n}\n\n//this function is called for each pixel\n//and returns color for this pixel\n//you can use it to preview output function\n//this does not affect the export result\nfloat4 main(float4 position) : SV_TARGET\n{\n\tfloat2 positionT=screenToUV(position);\n\t\n\tif(length(positionT-spacePointToUv(p.c))<0.01)\n\t\treturn float4(1,0,0,1);\n\t\n\tif(p.showUVRect)\n\t{\n\t    float w=0.005;\n\t    float2 fr= frac(positionT);\n\t    if(step(-w,fr.y)-step(w,fr.y)+step(-w,fr.x)-step(w,fr.x))\n\t    \treturn 1-output(positionT);\n\t}\n   \treturn output(positionT);\n}\n\n\nfloat geta2()\n{\n\treturn p.a2;\n}\n\n\n//this function called only once per frame before main\n//Allows to update parameters in one place\nvoid UpdateParameters(inout Parameters p)\n{\n\t//scale with mouse wheel\n\tp.zoom*=exp(p.mouse_wheel_delta*0.1);\n\t//movement with mouse\n\tif(p.lmb_down)\n\t\tp.move-=float2(p.mouse_delta.x,-p.mouse_delta.y)/p.extent.y/p.zoom*2;\n\n\t//c point\n\tif(p.rmb_down)\n\t\tp.c=uvToSpacePoint(screenToUV(p.mouse_pos/p.extent*2-1));\n\n\t//scale and move with keyboard\n\tif(isKeyDown(KEY_E))\n\t\tp.zoom*=exp(p.dt);\n\tif(isKeyDown(KEY_Q))\n\t\tp.zoom*=exp(-p.dt);\n\tfloat2 move_delta=float2(isKeyDown(KEY_D)-isKeyDown(KEY_A),isKeyDown(KEY_W)-isKeyDown(KEY_S));\n\tp.move+=move_delta*p.dt/p.zoom;\n\n\tif(isKeyPressed(KEY_F)||isKeyReleased(KEY_F))\n\t{\n\t\tp.mode=(p.mode+1)%4;\n\t}\n\t\n\tif(isKeyPressed(KEY_1))\n\t\tp.showUVRect=!p.showUVRect;\n\n\t//limits\n\tif(p.zoom<=0)\n\t\tp.zoom=0.1;\n\t\t\n\tp.a2=11;\n\tp.a1=geta2();\n\tp.a2=0;\n}\n\n\n\n\n\n\n"}],"name":"MandelbrotTemplate4d","parameters":{"members":{"a1":{"data":[0,0,0,0],"metadata":null,"name":"a1","offset":0,"type":"float"},"a2":{"data":[0,0,0,0],"metadata":null,"name":"a2","offset":4,"type":"float"},"accuracy":{"data":[0,0,36,66],"metadata":null,"name":"accuracy","offset":24,"type":"float"},"c":{"data":[19,24,25,-66,-20,93,77,63],"metadata":null,"name":"c","offset":32,"type":"vec2"},"color":{"data":[0,0,0,64,0,0,0,0,0,0,-128,63,0,0,-128,63],"metadata":null,"name":"color","offset":48,"type":"vec4"},"contrast":{"data":[0,0,0,65],"metadata":null,"name":"contrast","offset":40,"type":"float"},"dt":{"data":[58,65,-101,59],"metadata":null,"name":"dt","offset":116,"type":"float"},"extent":{"data":[0,0,32,69,0,0,-76,68,0,0,0,0],"metadata":null,"name":"extent","offset":68,"type":"vec2"},"lmb_down":{"data":[0,0,0,0],"metadata":null,"name":"lmb_down","offset":100,"type":"uint"},"mmb_down":{"data":[0,0,0,0],"metadata":null,"name":"mmb_down","offset":108,"type":"uint"},"mode":{"data":[2,0,0,0],"metadata":null,"name":"mode","offset":28,"type":"int"},"mouse_delta":{"data":[0,0,0,64,0,0,-96,64],"metadata":null,"name":"mouse_delta","offset":88,"type":"vec2"},"mouse_pos":{"data":[0,0,-18,66,0,0,42,67],"metadata":null,"name":"mouse_pos","offset":80,"type":"vec2"},"mouse_wheel_delta":{"data":[0,0,0,0],"metadata":null,"name":"mouse_wheel_delta","offset":96,"type":"float"},"move":{"data":[76,-75,-92,-66,85,-78,14,-65],"metadata":null,"name":"move","offset":8,"type":"vec2"},"radius":{"data":[0,0,0,64],"metadata":null,"name":"radius","offset":44,"type":"float"},"rmb_down":{"data":[0,0,0,0],"metadata":null,"name":"rmb_down","offset":104,"type":"uint"},"rotation":{"data":[0,0,0,0],"metadata":null,"name":"rotation","offset":20,"type":"float"},"showUVRect":{"data":[0,0,0,0],"metadata":null,"name":"showUVRect","offset":64,"type":"uint"},"t":{"data":[111,19,54,70],"metadata":null,"name":"t","offset":112,"type":"float"},"zoom":{"data":[-118,9,103,63],"metadata":null,"name":"zoom","offset":16,"type":"float"}},"size":120}}