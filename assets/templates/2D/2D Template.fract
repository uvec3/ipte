{"cache":[0,2,0,0,0,2,0,0,103,101,110,101,114,97,116,101,100,40,117,118,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11],"compilers":[{"isCurrent":true,"languageName":"HLSL","shaderName":"2D","source":"//It is possible to redefine float as double for better precision\n//(performance will be decreased significantly)\n//#define float2 double2\n//#define float double\n\n//define parameters\nstruct Parameters \n{\n    //custom parameters:\n    float a;\n\n\t//space transform:\n    float2 move; \n   \tfloat zoom;\n   \tfloat rotation;\n    \n    //preview parameters:\n    bool showUVRect;\n    bool showSpaceMesh;\n    float previewScale;\n\n    //reserved parameters,autoupdated by app:\n    float2 extent;//render area extent in pixels\n\tfloat2 mouse_pos;//current mouse position in pixels\n\tfloat2 mouse_delta;//mouse delta for the last frame in pixels\n\tfloat mouse_wheel_delta;//mouse wheel delta for the last frame\n\tbool lmb_down;//if left mouse button down\n\tbool rmb_down;//if right mouse button down\n\tbool mmb_down;//if middle mouse button down\n\tfloat t;//time counter\n\tfloat dt;//time passed from last frame\n};\n\n//define parameters variable p\nInputParameters(Parameters,p);\n\n\nfloat2 uvToSpacePoint(float2 uv)\n{\n\tfloat2x2 rot=float2x2(cos(p.rotation),sin(p.rotation),-sin(p.rotation),cos(p.rotation));\n\treturn rot*(uv / p.zoom +p.move);\n}\n\nfloat2 spacePointToUv(float2 spacePoint)\n{\n\tfloat2x2 rot=float2x2(cos(p.rotation),sin(p.rotation),-sin(p.rotation),cos(p.rotation));\n\treturn  (transpose(rot)*spacePoint-p.move)*p.zoom;\n}\n\n//This function will be the result of export\n//Pass parameters through function arguments for dynamic parameters\nfloat4 output(float2 uv)\n{\n\tfloat2 pos = uvToSpacePoint(uv);\n\n   \treturn pos.x*pos.y;\n}\n\nfloat2 screenToUV(float2 screenPosition)\n{\n\tscreenPosition.y=-screenPosition.y;\n\tfloat2 identitySquare;\n\tif(p.extent.x>p.extent.y)\n\t\tidentitySquare=float2(p.extent.y/p.extent.x,1);\n    else\n        identitySquare=float2(1,p.extent.x/p.extent.y);\n\treturn (screenPosition+identitySquare*p.previewScale*0.5)/identitySquare/p.previewScale;\n}\n\n//Function is called for each pixel\n//and returns color for this pixel\n//you can use it to preview output function\n//this does not affect the export result\nfloat4 main(float2 position)\n{\n\tfloat2 positionT = screenToUV(position);\n\t\n\tfloat4 result = output(positionT);\n\t\n\tif(p.showUVRect)\n\t{\n\t    float w=0.005/p.previewScale;\n\t    float2 fr= frac(positionT);\n\t    if(step(-w,fr.y)-step(w,fr.y)+step(-w,fr.x)-step(w,fr.x))\n\t    \treturn 1-result;\n\t}\n\t\n\tif(p.showSpaceMesh)\n\t{\n\t    float w=0.005/p.previewScale;\n\t    float2 fr= frac(uvToSpacePoint(positionT));\n\t    if(step(-w,fr.y)-step(w,fr.y)+step(-w,fr.x)-step(w,fr.x))\n\t    \treturn float4(0.5,0.5,1,1);\n\t}\n\t\n   \treturn result;\n}\n\n\n//this function called only once per frame before main\n//Allows to control parameters in one place\nvoid UpdateParameters(inout Parameters p) \n{\n\t//scale with mouse wheel\n\tif(!isKeyDown(KEY_Shift)&&!isKeyDown(KEY_Alt))\n\t{\n\t    float2 mouseBeforeZoom=screenToUV(p.mouse_pos/p.extent*2-1);\n\t    float zoomScale=exp(p.mouse_wheel_delta*0.1);\n\t    float2 mouseAfterZoom=mouseBeforeZoom*zoomScale;\n\t    p.zoom*=zoomScale;\n\t    p.move-=(mouseBeforeZoom-mouseAfterZoom)/p.zoom;\n     }\n     else if(isKeyDown(KEY_Alt))//rotate with Alt and mouse wheel\n     {\n     \tfloat delta=p.mouse_wheel_delta*0.1;\n     \tp.rotation+=delta;\n     \tfloat2x2 rot=float2x2(cos(delta),sin(delta),-sin(delta),cos(delta));\n     \tp.move=p.move*rot;\n     }\n     \n\t//movement with mouse\n\tif(p.lmb_down)\n\t\tp.move-=float2(p.mouse_delta.x,-p.mouse_delta.y)/p.extent.y/p.zoom*2/p.previewScale;\n\n\t//scale and move with keyboard\n\tfloat scaleUpdate=exp((isKeyDown(KEY_E)-isKeyDown(KEY_Q) )*p.dt);\n\tp.zoom=p.zoom*scaleUpdate;\n\tp.move-=(0.5-0.5*scaleUpdate)/p.zoom;\n\n\tfloat2 move_delta=float2(isKeyDown(KEY_D)-isKeyDown(KEY_A),isKeyDown(KEY_W)-isKeyDown(KEY_S));\n\tp.move+=move_delta*p.dt/p.zoom;\n\n\t//preview parameters control\n\tif(isKeyPressed(KEY_1))\n\t\tp.showUVRect=!p.showUVRect;\n\tif(isKeyPressed(KEY_2))\n\t\tp.showSpaceMesh=!p.showSpaceMesh;\n\tif(isKeyDown(KEY_Shift))\n\t\tp.previewScale*=exp(p.mouse_wheel_delta*0.1);\n\n\t//limit parameters\n\tif(p.zoom<=0)\n\t\tp.zoom=0.1;\n}\n"}],"name":"2D","parameters":{"members":{"a":{"data":[0,0,0,0],"metadata":null,"name":"a","offset":0,"type":"float"},"dt":{"data":[-48,45,-49,59],"metadata":null,"name":"dt","offset":76,"type":"float"},"extent":{"data":[0,0,32,69,0,0,-76,68],"metadata":null,"name":"extent","offset":32,"type":"vec2"},"lmb_down":{"data":[0,0,0,0],"metadata":null,"name":"lmb_down","offset":60,"type":"uint"},"mmb_down":{"data":[0,0,0,0],"metadata":null,"name":"mmb_down","offset":68,"type":"uint"},"mouse_delta":{"data":[0,0,-128,-64,0,0,-96,65],"metadata":null,"name":"mouse_delta","offset":48,"type":"vec2"},"mouse_pos":{"data":[0,-64,35,68,0,0,-128,66],"metadata":null,"name":"mouse_pos","offset":40,"type":"vec2"},"mouse_wheel_delta":{"data":[0,0,0,0],"metadata":null,"name":"mouse_wheel_delta","offset":56,"type":"float"},"move":{"data":[-1,-15,-119,-65,-74,-87,-116,-65],"metadata":null,"name":"move","offset":4,"type":"vec2"},"previewScale":{"data":[-54,-52,-52,63],"metadata":null,"name":"previewScale","offset":28,"type":"float"},"rmb_down":{"data":[0,0,0,0],"metadata":null,"name":"rmb_down","offset":64,"type":"uint"},"rotation":{"data":[0,0,-128,50],"metadata":null,"name":"rotation","offset":16,"type":"float"},"showSpaceMesh":{"data":[1,0,0,0],"metadata":null,"name":"showSpaceMesh","offset":24,"type":"uint"},"showUVRect":{"data":[0,0,0,0],"metadata":null,"name":"showUVRect","offset":20,"type":"uint"},"t":{"data":[-56,-40,-100,70],"metadata":null,"name":"t","offset":72,"type":"float"},"zoom":{"data":[104,14,-26,62],"metadata":null,"name":"zoom","offset":12,"type":"float"}},"size":80}}